#!/bin/bash
# Note: This script is intentionally run with /bin/bash, rather than with the
#       version of bash installed by brew. This is because the version of bash
#       installed by brew can be edited by non-root users and therefore cannot
#       be trusted in this script intended to be run by root.

mount_windows_file_history() {
    if /sbin/mount | /usr/bin/grep "${1}" > /dev/null; then
        echo "Windows File History is already mounted."
        return
    fi

    /bin/mkdir "${1}"
    /usr/sbin/chown WindowsFileHistory:staff "${1}"
    /var/root/unlock-windows-file-history
    /usr/sbin/diskutil mount -mountOptions owners,nodev,noexec,nosuid,rw \
        -mountPoint "${1}" '{{ .windowsFileHistory.magicVolumeID }}'
}

pfctl_filtered() {
    local -r IFS=''
    local magic_error='***error'
    local line
    while read -r line; do
        case "${line}" in
            # Suppress some messages that aren't useful.
            'No ALTQ support in kernel');;
            'ALTQ related functions disabled');;
            'pfctl: Use of -f option, could result in flushing of rules');;
            'present in the main ruleset added by the system at startup.');;
            'See /etc/pf.conf for further details.');;
            '');;
            "${magic_error}")
                return 1
                ;;
            *)
                echo "${line}"
                ;;
        esac
    done < <(
        if ! /sbin/pfctl "${@}" 2>&1; then
            echo "${magic_error}"
        fi
    )
}

pf_define_anchor() {
    echo "Loading rules into ${1}..."
    pfctl_filtered \
        -D 'eth_int=en0' \
        -D 'plain_dns_listen={ 53 }' \
        -a "${1}" -f - && \
            echo "Succeeded loading rules into ${1}."
    echo
}

pf_is_configured() {
    {
        /sbin/pfctl -s References 2>/dev/null | /usr/bin/grep -q '\spfctl\s';
    } && {
        /sbin/pfctl -s rules 2>/dev/null | /usr/bin/grep -q '^anchor "com.cathyjf" all$';
    } && {
        /sbin/pfctl -s nat 2>/dev/null | /usr/bin/grep -q '^rdr-anchor "com.cathyjf" all$';
    }
}

ensure_pf_is_configured() {
    if pf_is_configured; then
        return 1
    fi
    pfctl_filtered -E -f - << 'CATHYJF_CONFIG'
scrub-anchor "com.apple/*"
nat-anchor "com.apple/*"
rdr-anchor "com.apple/*"
rdr-anchor "com.cathyjf" # Added by Cathy
dummynet-anchor "com.apple/*"
anchor "com.apple/*"
load anchor "com.apple" from "/etc/pf.anchors/com.apple"
anchor "com.cathyjf" # Added by Cathy
CATHYJF_CONFIG
}

pf_define_cathyjf_anchors() {
    pf_define_anchor 'com.cathyjf/filter-dns' << 'EOT'
# DNS over HTTPS
rdr on lo0 inet proto { tcp, udp } to port 443 -> 127.0.0.1 port 30443

# Plain DNS
rdr on lo0 inet proto udp to port 53 -> 127.0.0.1 port 30053
table <plain_dns_allowed> { samsung-tv }
table <plain_dns_target> { cathy-mac }
rdr on $eth_int inet proto udp \
    from <plain_dns_allowed> to <plain_dns_target> port $plain_dns_listen \
        -> 127.0.0.1 port 30053

# DNS over TLS (tcp) and Quic (udp)
rdr on lo0 inet proto { tcp, udp } to port 853 -> 127.0.0.1 port 30853
rdr on $eth_int inet proto { tcp, udp } \
    from 192.168.1.0/24 to cathy-mac port 853 -> 127.0.0.1 port 30853

# Block communications with public plain DNS servers over port 53.
# All DNS lookup requests should be performed securely, not over plain DNS.
block return in log on ! lo0 proto { tcp, udp } from ! <plain_dns_allowed> port 53
block return out log on ! lo0 proto { tcp, udp } to ! <plain_dns_allowed> port 53

# Drop unauthorized communications with a local plain DNS server.
block drop in log on ! lo0 proto { tcp, udp } from ! <plain_dns_allowed> to port $plain_dns_listen
block drop out log on ! lo0 proto { tcp, udp } from port $plain_dns_listen to ! <plain_dns_allowed>

# Prevent accidentally exposing a local plain DNS server to the internet.
block drop in log on ! lo0 proto { tcp, udp } to ! <plain_dns_target> port $plain_dns_listen
block drop out log on ! lo0 proto { tcp, udp } from ! <plain_dns_target> port $plain_dns_listen
EOT

    pf_define_anchor 'com.cathyjf/filter-root' << 'EOT'
# Block and log unexpected incoming connection attempts to root processes.
# This anchor doesn't really provide security; it's mainly intended to alert me
# to instances of accidental misconfiguration.
pass out on ! lo0 proto { tcp, udp } user root
block return in log on ! lo0 proto { tcp, udp } user root
pass in on ! lo0 proto tcp to port 22 user root
EOT

    pf_define_anchor 'com.cathyjf/filter-internet' << 'EOT'
# Drop and log incoming connections from the internet.
table <local_hosts> { self $eth_int:network fe80::/10 10.0.0.10 172.16.42.0/24 }
# The following two rules are both necessary. The first rule ensures that state
# is created for most outgoing connections. The second rule then carves out an
# exception so that no state is created for connections between two hosts on
# the local network; this avoids maintaining state on connections where such
# state is not required to enforce this anchor's policy.
pass out on ! lo0
pass out on ! lo0 from <local_hosts> to <local_hosts> no state
block drop in log on ! lo0 from ! <local_hosts>
EOT

    pf_define_anchor 'com.cathyjf/filter-vhusb' << 'EOT'
# VirtualHere USB Server
# All connections should go over ssh, so block all direct network connectivity.
block return in log proto tcp to port 7575 # normal TCP connection
block return out log proto tcp to port 7573 # reverse TCP connection

# Also allow VirtualHere USB Server outgoing traffic over the VPN on ppp0.
pass out on ppp0 proto tcp to 10.0.0.10 port 7573
EOT

    pf_define_anchor 'com.cathyjf/filter-deskflow' << 'EOT'
# Deskflow (Synergy)
# All connections should go over ssh, so block all direct network connectivity.
block return in log on ! lo0 proto tcp to port {{ .synergy.serverPort }}
EOT

    pf_define_anchor 'com.cathyjf/filter-samba' << 'EOT'
# Samba
block return in log on ! lo0 proto tcp to port 445
table <samba_allowed> { \
    cathy-alienware, cathy-mac, cathy-macbookair, cathy-macbookair-wifi \
}
pass in on $eth_int inet proto tcp from <samba_allowed> to cathy-mac port 445
EOT

    pf_define_anchor 'com.cathyjf' << 'EOT'
# Normalization rules
scrub in on ! lo0

# Translation rules
rdr-anchor "filter-dns"

# Filtering rules
anchor "filter-internet"
anchor "filter-vhusb"
anchor "filter-deskflow"
anchor "filter-samba"
anchor "filter-dns"

# Unfortunately, the `filter-root` anchor blocks AirPlay. This is not a simple
# problem to fix, so this anchor needs to be disabled for now.
# anchor "filter-root"
EOT
}

configure_application_firewall() {
    # Apply some rules to the macOS application firewall.
    local smbd_path
    smbd_path="$(/usr/bin/readlink -f '{{ template `brew-root` . }}'/sbin/samba-dot-org-smbd)"
    local vhserver=/Applications/VirtualHereServerUniversal.app
    local adguardhome=/Applications/AdGuardHome/AdGuardHome
    /usr/libexec/ApplicationFirewall/socketfilterfw \
        --setglobalstate on \
        --setallowsigned off --setallowsignedapp off --setstealthmode on \
        --add "${smbd_path}" --unblockapp "${smbd_path}" \
        --add "${vhserver}" --blockapp "${vhserver}" \
        --add "${adguardhome}" --blockapp "${adguardhome}"
}

start_firewalls() {
    configure_application_firewall
    pf_define_cathyjf_anchors
    if ! ensure_pf_is_configured; then
        return 1
    fi
}

mount_windows_file_history "/Volumes/Windows File History" &
declare exit_status=0
start_firewalls || exit_status="${?}"
wait
exit "${exit_status}"